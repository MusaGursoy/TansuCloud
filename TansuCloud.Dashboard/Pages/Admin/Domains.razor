@page "/admin/domains"
@layout TansuCloud.Dashboard.Pages.Admin.AdminLayout
@using System.Net.Http.Headers
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@inject HttpClient Http
@inject IJSRuntime JS
@inject IDialogService DialogService

<PageTitle>Domains & TLS | TansuCloud Admin</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-2">Domains & TLS</MudText>
    <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mb-4">
        Manage TLS certificates and domain bindings for secure HTTPS connections.
    </MudText>

    <!-- Current Bindings Section -->
    <MudText Typo="Typo.h5" Class="mb-3">Current bindings</MudText>

    @if (_bindings is null)
    {
        <div class="d-flex justify-content-center py-5">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        </div>
    }
    else if (_bindings.Count == 0)
    {
        <MudAlert Severity="Severity.Info" Class="mb-4">
            No bindings yet. Add a certificate below to get started.
        </MudAlert>
    }
    else
    {
        <MudTable T="DomainBindingInfo" Items="@_bindings" Hover="true" Dense="true" Striped="true" Elevation="2" Class="mb-4">
            <HeaderContent>
                <MudTh>Host</MudTh>
                <MudTh>Subject</MudTh>
                <MudTh>Issuer</MudTh>
                <MudTh>Thumbprint</MudTh>
                <MudTh>Valid To</MudTh>
                <MudTh>Hostname Match</MudTh>
                <MudTh>Chain</MudTh>
                <MudTh Style="text-align: right;">Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Host">@context.Host</MudTd>
                <MudTd DataLabel="Subject">@context.Subject</MudTd>
                <MudTd DataLabel="Issuer">@context.Issuer</MudTd>
                <MudTd DataLabel="Thumbprint"><code>@context.Thumbprint</code></MudTd>
                <MudTd DataLabel="Valid To">@context.NotAfter.ToLocalTime()</MudTd>
                <MudTd DataLabel="Hostname Match">
                    @if (context.HostnameMatches)
                    {
                        <MudChip T="string" Size="Size.Small" Color="Color.Success">Yes</MudChip>
                    }
                    else
                    {
                        <MudChip T="string" Size="Size.Small" Color="Color.Warning">No</MudChip>
                    }
                </MudTd>
                <MudTd DataLabel="Chain">
                    @if (context.ChainProvided)
                    {
                        <MudTooltip Text="Chain count and linkage">
                            <span>@context.ChainCount @(context.ChainValidated ? "(linked)" : "(unlinked)")</span>
                        </MudTooltip>
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="Actions" Style="text-align: right;">
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" Size="Size.Small" 
                               OnClick="@(() => RemoveAsync(context.Host))" 
                               StartIcon="@Icons.Material.Filled.Delete">
                        Remove
                    </MudButton>
                </MudTd>
            </RowTemplate>
        </MudTable>
    }

    <MudButton Variant="Variant.Outlined" Color="Color.Default" OnClick="LoadAsync" 
               StartIcon="@Icons.Material.Filled.Refresh" Class="mb-4">
        Refresh
    </MudButton>

    @if (!string.IsNullOrEmpty(_err))
    {
        <MudAlert Severity="Severity.Error" ShowCloseIcon="true" CloseIconClicked="@(() => _err = null)" Class="mb-4">
            @_err
        </MudAlert>
    }

    <MudDivider Class="my-4" />

    <!-- Add or Replace Binding Section -->
    <MudCard Elevation="2" Class="mb-4">
        <MudCardHeader>
            <CardHeaderContent>
                <MudText Typo="Typo.h6">Add or replace binding</MudText>
            </CardHeaderContent>
        </MudCardHeader>
        <MudCardContent>
            <MudTextField @bind-Value="_host" Label="Host" Placeholder="e.g. app.example.com" 
                          Variant="Variant.Outlined" Class="mb-3" />

            <MudText Typo="Typo.subtitle2" Class="mb-2">Option 1: PFX File</MudText>
            <MudFileUpload T="IBrowserFile" Accept=".pfx" OnFilesChanged="OnInputFileChanged" MaximumFileCount="1">
                <ActivatorContent>
                    <MudButton Variant="Variant.Outlined" Color="Color.Default" 
                               StartIcon="@Icons.Material.Filled.AttachFile">
                        @if (_pfxBytes is null)
                        {
                            <span>Select PFX file</span>
                        }
                        else
                        {
                            <span>PFX selected (@_pfxBytes.Length bytes)</span>
                        }
                    </MudButton>
                </ActivatorContent>
            </MudFileUpload>

            <MudTextField T="string" @bind-Value="_pfxPassword" Label="Password (optional)" 
                          InputType="InputType.Password" Variant="Variant.Outlined" Class="mt-3 mb-4" />

            <MudDivider Class="my-4" />

            <MudText Typo="Typo.subtitle2" Class="mb-2">Option 2: Paste PEM certificate + private key</MudText>

            <MudTextField @bind-Value="_certPem" Label="PEM certificate" Lines="4" 
                          Placeholder="-----BEGIN CERTIFICATE-----" 
                          Variant="Variant.Outlined" Class="mb-3 font-monospace" />

            <MudTextField @bind-Value="_keyPem" Label="PEM private key" Lines="6" 
                          Placeholder="-----BEGIN PRIVATE KEY-----" 
                          Variant="Variant.Outlined" Class="mb-3 font-monospace" />

            <MudTextField @bind-Value="_chainPem" Label="PEM chain (optional)" Lines="6" 
                          Placeholder="Concatenate intermediate certificates in PEM format" 
                          Variant="Variant.Outlined" Class="mb-3 font-monospace" />

            <MudTextField @bind-Value="_csrf" Label="Admin CSRF (if configured)" 
                          Placeholder="X-Tansu-Csrf value" Variant="Variant.Outlined" Class="mb-3" />
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!_canSave)" 
                       OnClick="SaveAsync" StartIcon="@Icons.Material.Filled.Save">
                Save (PFX)
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!_canSavePem)" 
                       OnClick="SavePemAsync" StartIcon="@Icons.Material.Filled.Save" Class="ms-2">
                Save (PEM)
            </MudButton>
        </MudCardActions>
        @if (!string.IsNullOrEmpty(_saveMsg))
        {
            <MudCardContent>
                <MudAlert Severity="@(_saveMsg.Contains("Error") ? Severity.Error : Severity.Success)">
                    @_saveMsg
                </MudAlert>
            </MudCardContent>
        }
    </MudCard>

    <!-- Rotate Certificate Section -->
    <MudCard Elevation="2" Class="mb-4">
        <MudCardHeader Style="background-color: var(--mud-palette-warning); color: white;">
            <CardHeaderContent>
                <MudText Typo="Typo.h6">Rotate certificate</MudText>
            </CardHeaderContent>
        </MudCardHeader>
        <MudCardContent>
            <MudTextField @bind-Value="_rotateHost" Label="Host" Placeholder="host to rotate" 
                          Variant="Variant.Outlined" Class="mb-3" />

            <MudText Typo="Typo.subtitle2" Class="mb-2">Option 1: PFX File (alternative)</MudText>
            <MudGrid>
                <MudItem xs="12" md="8">
                    <MudFileUpload T="IBrowserFile" Accept=".pfx" OnFilesChanged="OnRotatePfxChanged" MaximumFileCount="1">
                        <ActivatorContent>
                            <MudButton Variant="Variant.Outlined" Color="Color.Default" 
                                       StartIcon="@Icons.Material.Filled.AttachFile" FullWidth="true">
                                @if (_rotatePfx is null)
                                {
                                    <span>Select PFX file</span>
                                }
                                else
                                {
                                    <span>PFX selected (@_rotatePfx.Length bytes)</span>
                                }
                            </MudButton>
                        </ActivatorContent>
                    </MudFileUpload>
                </MudItem>
                <MudItem xs="12" md="4">
                    <MudTextField T="string" @bind-Value="_rotatePfxPwd" Label="Password (optional)" 
                                  InputType="InputType.Password" Variant="Variant.Outlined" />
                </MudItem>
            </MudGrid>

            <MudDivider Class="my-4" />

            <MudText Typo="Typo.subtitle2" Class="mb-2">Option 2: Paste PEM certificate + private key</MudText>

            <MudTextField @bind-Value="_rotateCertPem" Label="PEM certificate" Lines="4" 
                          Placeholder="-----BEGIN CERTIFICATE-----" 
                          Variant="Variant.Outlined" Class="mb-3 font-monospace" />

            <MudTextField @bind-Value="_rotateKeyPem" Label="PEM private key" Lines="6" 
                          Placeholder="-----BEGIN PRIVATE KEY-----" 
                          Variant="Variant.Outlined" Class="mb-3 font-monospace" />

            <MudTextField @bind-Value="_rotateChainPem" Label="PEM chain (optional)" Lines="6" 
                          Placeholder="Concatenate intermediate certificates in PEM format" 
                          Variant="Variant.Outlined" Class="mb-3 font-monospace" />
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Warning" Disabled="@(!_canRotate)" 
                       OnClick="RotateAsync" StartIcon="@Icons.Material.Filled.Autorenew">
                Rotate
            </MudButton>
        </MudCardActions>
        @if (!string.IsNullOrEmpty(_rotateMsg))
        {
            <MudCardContent>
                <MudAlert Severity="@(_rotateMsg.Contains("Error") ? Severity.Error : Severity.Success)">
                    @_rotateMsg
                </MudAlert>
            </MudCardContent>
        }
    </MudCard>
</MudContainer>

@code {
    private List<DomainBindingInfo>? _bindings;
    private string? _err;
    private string _host = string.Empty;
    private byte[]? _pfxBytes;
    private string? _pfxPassword;
    private string? _saveMsg;
    private string? _csrf;

    // PEM state
    private string? _certPem;
    private string? _keyPem;
    private string? _chainPem;

    // Rotate state
    private string _rotateHost = string.Empty;
    private byte[]? _rotatePfx;
    private string? _rotatePfxPwd;
    private string? _rotateCertPem;
    private string? _rotateKeyPem;
    private string? _rotateChainPem;
    private string? _rotateMsg;

    private bool _canSave => !string.IsNullOrWhiteSpace(_host) && _pfxBytes is not null;
    private bool _canSavePem => !string.IsNullOrWhiteSpace(_host) && !string.IsNullOrWhiteSpace(_certPem) && !string.IsNullOrWhiteSpace(_keyPem);
    private bool _canRotate
        => !string.IsNullOrWhiteSpace(_rotateHost) && (
                (_rotatePfx is not null) || (!string.IsNullOrWhiteSpace(_rotateCertPem) && !string.IsNullOrWhiteSpace(_rotateKeyPem))
           );

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
    } // End of Method OnInitializedAsync

    private async Task LoadAsync()
    {
        try
        {
            _err = null;
            var res = await Http.GetAsync("/admin/api/domains");
            res.EnsureSuccessStatusCode();
            var json = await res.Content.ReadAsStringAsync();
            _bindings = JsonSerializer.Deserialize<List<DomainBindingInfo>>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }) ?? new();
        }
        catch (Exception ex)
        {
            _err = ex.Message;
        }
    } // End of Method LoadAsync

    private async Task SaveAsync()
    {
        _saveMsg = null;
        try
        {
            if (_pfxBytes is null) return;
            var payload = new {
                host = _host,
                pfxBase64 = Convert.ToBase64String(_pfxBytes),
                pfxPassword = _pfxPassword
            };
            using var req = new HttpRequestMessage(HttpMethod.Post, "/admin/api/domains")
            {
                Content = JsonContent.Create(payload)
            };
            if (!string.IsNullOrWhiteSpace(_csrf)) req.Headers.Add("X-Tansu-Csrf", _csrf);
            var res = await Http.SendAsync(req);
            if (res.IsSuccessStatusCode)
            {
                _saveMsg = "Saved";
                await LoadAsync();
            }
            else
            {
                _saveMsg = $"Error: {(int)res.StatusCode} {res.ReasonPhrase}";
            }
        }
        catch (Exception ex)
        {
            _saveMsg = ex.Message;
        }
    } // End of Method SaveAsync

    private async Task SavePemAsync()
    {
        _saveMsg = null;
        try
        {
            if (string.IsNullOrWhiteSpace(_certPem) || string.IsNullOrWhiteSpace(_keyPem)) return;
            var payload = new {
                host = _host,
                certPem = _certPem,
                keyPem = _keyPem,
                chainPem = _chainPem
            };
            using var req = new HttpRequestMessage(HttpMethod.Post, "/admin/api/domains/pem")
            {
                Content = JsonContent.Create(payload)
            };
            if (!string.IsNullOrWhiteSpace(_csrf)) req.Headers.Add("X-Tansu-Csrf", _csrf);
            var res = await Http.SendAsync(req);
            if (res.IsSuccessStatusCode)
            {
                _saveMsg = "Saved (PEM)";
                await LoadAsync();
            }
            else
            {
                _saveMsg = $"Error: {(int)res.StatusCode} {res.ReasonPhrase}";
            }
        }
        catch (Exception ex)
        {
            _saveMsg = ex.Message;
        }
    } // End of Method SavePemAsync

    private async Task RemoveAsync(string host)
    {
        try
        {
            var res = await Http.DeleteAsync($"/admin/api/domains/{Uri.EscapeDataString(host)}");
            if (res.IsSuccessStatusCode)
            {
                await LoadAsync();
            }
            else
            {
                _err = $"Delete failed: {(int)res.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            _err = ex.Message;
        }
    } // End of Method RemoveAsync

    private async Task OnInputFileChanged(InputFileChangeEventArgs e)
    {
        _pfxBytes = null;
        var file = e.File;
        if (file is null)
            return;
        await using var stream = file.OpenReadStream(maxAllowedSize: 512 * 1024); // 512 KB limit for PFX
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        _pfxBytes = ms.ToArray();
    } // End of Method OnInputFileChanged

    private async Task OnRotatePfxChanged(InputFileChangeEventArgs e)
    {
        _rotatePfx = null;
        var file = e.File;
        if (file is null) return;
        await using var stream = file.OpenReadStream(maxAllowedSize: 512 * 1024);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        _rotatePfx = ms.ToArray();
    } // End of Method OnRotatePfxChanged

    private async Task RotateAsync()
    {
        _rotateMsg = null;
        try
        {
            // Confirmation prompt for safety
            if (string.IsNullOrWhiteSpace(_rotateHost)) return;
            var confirmText = $"Rotate certificate for '{_rotateHost}'? This will replace the current binding.";
            if (!await JS.InvokeAsync<bool>("confirm", confirmText))
            {
                _rotateMsg = "Cancelled";
                return;
            }
            object payload;
            if (_rotatePfx is not null)
            {
                payload = new { host = _rotateHost, pfxBase64 = Convert.ToBase64String(_rotatePfx), pfxPassword = _rotatePfxPwd };
            }
            else
            {
                payload = new { host = _rotateHost, certPem = _rotateCertPem, keyPem = _rotateKeyPem, chainPem = _rotateChainPem };
            }
            using var req = new HttpRequestMessage(HttpMethod.Post, "/admin/api/domains/rotate")
            {
                Content = JsonContent.Create(payload)
            };
            if (!string.IsNullOrWhiteSpace(_csrf)) req.Headers.Add("X-Tansu-Csrf", _csrf);
            var res = await Http.SendAsync(req);
            if (res.IsSuccessStatusCode)
            {
                try
                {
                    var json = await res.Content.ReadAsStringAsync();
                    var doc = JsonDocument.Parse(json);
                    var cur = doc.RootElement.GetProperty("current");
                    string curThumb = cur.GetProperty("thumbprint").GetString() ?? string.Empty;
                    DateTimeOffset curExp = cur.GetProperty("notAfter").GetDateTimeOffset();
                    string? prevThumb = null;
                    DateTimeOffset? prevExp = null;
                    if (doc.RootElement.TryGetProperty("previous", out var prev) && prev.ValueKind != JsonValueKind.Null)
                    {
                        prevThumb = prev.GetProperty("thumbprint").GetString();
                        prevExp = prev.GetProperty("notAfter").GetDateTimeOffset();
                    }
                    _rotateMsg = prevThumb is null
                        ? $"Rotated. New thumbprint: {curThumb}, expires {curExp.ToLocalTime()}"
                        : $"Rotated. New {curThumb} (exp {curExp.ToLocalTime()}), prev {prevThumb} (exp {prevExp?.ToLocalTime()})";
                }
                catch
                {
                    _rotateMsg = "Rotated";
                }
                await LoadAsync();
            }
            else
            {
                _rotateMsg = $"Error: {(int)res.StatusCode} {res.ReasonPhrase}";
            }
        }
        catch (Exception ex)
        {
            _rotateMsg = ex.Message;
        }
    } // End of Method RotateAsync

    public sealed class DomainBindingInfo
    {
        public string Host { get; set; } = string.Empty;
        public string Subject { get; set; } = string.Empty;
        public string Issuer { get; set; } = string.Empty;
        public string Thumbprint { get; set; } = string.Empty;
        public DateTimeOffset NotBefore { get; set; }
        public DateTimeOffset NotAfter { get; set; }
        public bool HasPrivateKey { get; set; }
        public bool HostnameMatches { get; set; }
        public bool ChainProvided { get; set; }
        public bool ChainValidated { get; set; }
        public int ChainCount { get; set; }
    } // End of Class DomainBindingInfo
} // End of Class Domains
