# Tansu.Cloud Admin & Tenant Guide

## Overview

Tansu.Cloud is a modern backend-as-a-service (BaaS) platform built on .NET, providing identity, API gateway, dashboards, database and storage services, observability, and health management. This guide helps admins and tenant operators deploy, configure, and operate the platform.

## 1. Getting Started

- Architecture at a glance
- Core services and responsibilities
- Environments (dev, staging, production)

## 2. Prerequisites

- Docker and Docker Compose
- Certificates (PFX) for TLS
- DNS and firewall basics

## 3. Quickstart: Local Development

- Run all services with VS Code tasks (dev: up / dev: down)
- Running with Docker Compose (gateway only exposed)
- Health endpoints (/health/live and /health/ready)

## 4. Production Topology

- Gateway-only exposure (80/443)
- Internal service networking
- OpenTelemetry collector

### 4.1 Custom domain and secrets (.env)

Set your public base URL and sensitive values via a `.env` file next to `docker-compose.yml`. Docker Compose will auto-load it and substitute values into service environments.

1) Create `.env` with your domain and secrets

```env
# Public HTTPS base URL of your gateway (include scheme; no trailing slash)
PUBLIC_BASE_URL=https://your-domain

# Dashboard OIDC confidential client secret (used by the Dashboard to obtain tokens)
DASHBOARD_CLIENT_SECRET=replace-with-strong-secret

# Postgres and PgCat credentials used by the stack
POSTGRES_USER=postgres
POSTGRES_PASSWORD=change-me
PGCAT_ADMIN_USER=admin
PGCAT_ADMIN_PASSWORD=change-me

# If you enable TLS on the gateway (see section 5), set the PFX password
GATEWAY_CERT_PASSWORD=changeit
```

2) What these influence

- PUBLIC_BASE_URL configures all OIDC and callback URLs exposed externally:
	- Identity issuer: `${PUBLIC_BASE_URL}/identity/`
	- Dashboard OIDC authority: `${PUBLIC_BASE_URL}/identity`
	- Redirect URIs (dashboard behind gateway path):
		- `${PUBLIC_BASE_URL}/dashboard/signin-oidc`
		- `${PUBLIC_BASE_URL}/dashboard/signout-callback-oidc`
	- Root variants (if you front the dashboard at the domain root as an alternative):
		- `${PUBLIC_BASE_URL}/signin-oidc`
		- `${PUBLIC_BASE_URL}/signout-callback-oidc`
- DASHBOARD_CLIENT_SECRET is injected into the Dashboard container as its client secret.
- POSTGRES_* and PGCAT_* configure the database and PgCat admin access used by services.
- GATEWAY_CERT_PASSWORD is only required when HTTPS is enabled on the gateway with a PFX (see 5.x).

3) DNS and TLS

- Point your domain (A/AAAA) to the gateway host.
- Use a valid certificate (section 5) and set `PUBLIC_BASE_URL` to the HTTPS origin.
- After the first start, confirm discovery at `${PUBLIC_BASE_URL}/identity/.well-known/openid-configuration`.

## 5. Certificates & TLS

- Preparing a PFX certificate
- Mounting certs via Compose (volumes)
- Configuring Kestrel HTTPS in gateway (appsettings Kestrel:Endpoints)
- Setting GATEWAY_CERT_PASSWORD

### 5.1 Dev SSL (self‑signed)

Use the helper script to create a local, self‑signed PFX and wire it to the gateway:

1. Generate a dev certificate

- Script: `dev/make-dev-cert.ps1`
- Output: `./certs/gateway.pfx` (you’ll be prompted for a password)

1. Point the gateway to the PFX

- HTTPS is disabled by default. Enable it via Docker Compose by mounting the PFX, exposing 443, and setting Kestrel HTTPS endpoint via environment variables:

```yaml
services:
	gateway:
		ports:
			- "80:8080"
			- "443:8443"            # enable HTTPS (container listens on 8443)
		volumes:
			- ./certs:/certs:ro      # contains gateway.pfx
		environment:
			- Kestrel__Endpoints__Https__Url=https://0.0.0.0:8443
			- Kestrel__Endpoints__Https__Certificate__Path=/certs/gateway.pfx
			- GATEWAY_CERT_PASSWORD=${GATEWAY_CERT_PASSWORD}
```

1. Provide the password

- Set `GATEWAY_CERT_PASSWORD` via `.env` or shell; it’s read at startup and used as the PFX password. See 5.3 for examples.

1. Browse

- Start compose; navigate to `https://localhost` (trust the self‑signed cert in your browser if prompted).

### 5.2 Real SSL (public CA)

1. Obtain a PFX for your domain

- Include the full chain (intermediate CAs) and set a strong password.

1. Mount and configure

- Place the PFX where Docker can mount it (e.g., `./certs/mydomain.pfx`).
- Configure the HTTPS endpoint via environment variables. The password must be provided via `GATEWAY_CERT_PASSWORD` using a `.env` file or shell variable (see 5.3):

```yaml
services:
	gateway:
		ports:
			- "80:8080"
			- "443:8443"
		volumes:
			- ./certs:/certs:ro
		environment:
			- Kestrel__Endpoints__Https__Url=https://0.0.0.0:8443
			- Kestrel__Endpoints__Https__Certificate__Path=/certs/mydomain.pfx
			- GATEWAY_CERT_PASSWORD=${GATEWAY_CERT_PASSWORD}
```

- Or re-add the Https endpoint in appsettings to pin the URL; still provide the password via `GATEWAY_CERT_PASSWORD` only (see 5.3).

1. DNS and callbacks

- Point your DNS (A/AAAA) to the gateway host.
- Update OIDC redirect URIs and issuers to use your HTTPS host.

1. Hardening (recommended)

- Enable HSTS, fine‑tune CORS allowlists, and use secret stores for certificate passwords.

### 5.3 How to provide the certificate password

Provide the password only via the environment variable `GATEWAY_CERT_PASSWORD`. Do not store it in appsettings or source control.

Option A — .env file (recommended for local/dev)

1. Create a `.env` file next to `docker-compose.yml` with:

```env
GATEWAY_CERT_PASSWORD=changeit
```

1. Ensure your gateway service `environment` section contains:

```yaml
environment:
	- Kestrel__Endpoints__Https__Url=https://0.0.0.0:8443
	- Kestrel__Endpoints__Https__Certificate__Path=/certs/gateway.pfx
	- GATEWAY_CERT_PASSWORD=${GATEWAY_CERT_PASSWORD}
```

Docker Compose will automatically load `.env` and substitute the value.

Option B — Shell environment variable (one-off runs, CI/CD)

- Windows PowerShell

```powershell
$env:GATEWAY_CERT_PASSWORD = "changeit"
docker compose up -d
```

- Bash (Linux/macOS)

```bash
export GATEWAY_CERT_PASSWORD=changeit
docker compose up -d
```

Notes

- Don’t commit real passwords into source control. Use `.env` (ignored by default) or secret managers/CI secrets.
- For HTTP-only runs, leave 443 and TLS envs unset, and (in dev) you can set `Gateway:DisableHttpsRedirect=true` to prevent redirects.

## 6. Identity & Authentication

- Identity issuer and discovery under /identity
- Configuring OIDC issuer for downstream services (Oidc:Issuer)
- Dashboard OIDC authority configuration

Recommended settings

- In production, set `PUBLIC_BASE_URL` to your HTTPS origin in `.env`. The compose file maps this to:
	- Identity Issuer: `${PUBLIC_BASE_URL}/identity/`
	- Dashboard Authority/Metadata: `${PUBLIC_BASE_URL}/identity`
	- Dashboard Redirect URIs:
		- `${PUBLIC_BASE_URL}/dashboard/signin-oidc`
		- `${PUBLIC_BASE_URL}/dashboard/signout-callback-oidc`
	- Optional root variants for alternative routing:
		- `${PUBLIC_BASE_URL}/signin-oidc`
		- `${PUBLIC_BASE_URL}/signout-callback-oidc`
- Set the Dashboard confidential client secret via `DASHBOARD_CLIENT_SECRET` in `.env`.
- Ensure reverse proxy forwarding headers are correct at the gateway; Identity relies on them for issuer/redirects.

## 7. Configuration & Secrets

- Configuration sources (appsettings, environment, user secrets)
- Sensitive values (client secrets, cert passwords)
- Example environment variables and key paths

## 8. Health & Monitoring

- Health endpoints and readiness gates
- OpenTelemetry signals (traces, metrics, logs)
- Collector endpoint and backends

## 9. Operations

- Rolling updates and restarts
- Log collection and troubleshooting
- Backup and restore considerations (DB/storage specifics TBD)

## 10. Security Hardening

- CORS at the gateway
- TLS everywhere and HSTS (optional)
- Rate limiting and body size limits at the gateway

## 11. Multi-Tenancy

- Tenant resolution via host/path
- Header propagation (X-Tansu-Tenant)
- Tenant-aware caching and routing

## 12. Troubleshooting

- Common startup issues
- Certificate and TLS errors
- OIDC discovery and token validation

## 13. Testing & E2E validation

This platform ships with lightweight health checks and end-to-end (E2E) tests that verify core paths through the gateway, identity, and backend services.

### 13.1 Local quick checks

- Health endpoints (all services):
	- Live: `GET /health/live`
	- Ready: `GET /health/ready`
	- Via gateway for each service: `/`, `/identity/`, `/dashboard/`, `/db/`, `/storage/` then append `/health/live` or `/health/ready`.
- Bring services up (developer workflow):
	- VS Code → Run Task… → "dev: up" to build and start services.
	- VS Code → Run Task… → "dev: down" to stop them.
- Dev database (PostgreSQL) recommended for DB features:
	- Use the persistent Citus/Postgres container described earlier, or the helper script at `dev/tools/start-dev-db.ps1`.

### 13.2 Run E2E tests locally

- The E2E test suite lives under `tests/TansuCloud.E2E.Tests` and targets the gateway at `http://localhost:8080` (default dev bind). If you enabled HTTPS on the gateway, adjust the base URL accordingly.
- What is covered today:
	- Health endpoints across services.
	- Identity UI login alias via gateway.
	- Token-based, idempotent tenant provisioning to Database via gateway.
- How to run:
	- Ensure services are up (see 13.1) and that a local PostgreSQL is reachable at `localhost:5432` (the default dev setup).
	- In VS Code, Run Task… → "Run all E2E tests"; or run tests from your IDE/test explorer.
	- Tip: you can run focused suites via provided VS Code tasks (e.g., "Run health E2E tests").
- Notes:
	- Tests accept development HTTPS certificates; no extra trust steps needed for local runs.
	- The provisioning test obtains an access token using the dashboard client (scopes: `db.write admin.full`) and calls the Database provisioning API twice, asserting idempotency.

### 13.2.1 Redis-dependent outbox test gating

Some outbox E2E validation requires a real Redis instance (publishing and subscription). These tests are decorated with a custom attribute `RedisFactAttribute` and will be reported as Skipped unless the environment variable `REDIS_URL` is set.

To enable the Redis E2E outbox test locally:

1. Start (or ensure) a Redis container/service is running and reachable.
2. Export `REDIS_URL` before running tests:

```powershell
$env:REDIS_URL = "localhost:6379" # or full configuration string supported by StackExchange.Redis
dotnet test .\tests\TansuCloud.E2E.Tests\TansuCloud.E2E.Tests.csproj -c Debug --filter Full_Dispatcher_Redis_Publish
```

Example skip output when not configured:

```
Full dispatcher loop publishes to Redis and marks dispatched (E2E) [SKIP]
	REDIS_URL not set; Redis-dependent test skipped
```

Rationale:
- Keeps CI fast and deterministic when Redis isn’t provisioned.
- Avoids false negatives due to missing ephemeral infrastructure.
- Local developers can opt-in for the extra signal when modifying outbox/Redis code paths.

If you routinely run with Redis, consider adding a VS Code test task that sets `REDIS_URL` inline so the attribute no longer skips the test.

### 13.5 Database API v1 quick reference

Base path via gateway: `/db/api` (tenant required via `X-Tansu-Tenant` header). Auth scopes: `db.read` for reads, `db.write` for writes (in Development, `admin.full` implies both).

- Collections
	- `GET /collections` — list with pagination; supports weak ETag on the collection set.
	- `GET /collections/{id}` — get by id; weak ETag; `If-None-Match` → 304.
	- `POST /collections` — create.
	- `PUT /collections/{id}` — update; `If-Match` required for conditional update; 412 on mismatch.
	- `DELETE /collections/{id}` — delete; `If-Match` supported; 412 on mismatch.

- Documents
	- `GET /documents` — list with filters/sort and pagination.
		- Query: `collectionId` (Guid?), `createdAfter`|`createdBefore` (RFC3339), `sortBy` in `id|collectionId|createdAt`, `sortDir` in `asc|desc`, `page` (>=1), `pageSize` (1..500).
		- Weak ETag on the result; `If-None-Match` → 304.
	- `GET /documents/{id}` — get by id; weak ETag; `If-None-Match` → 304.
	- `POST /documents` — create; body includes `collectionId`, optional `embedding` (float[1536]) and `content` (JSON object). JSON payloads are stored as `jsonb`.
	- `PUT /documents/{id}` — update; supports `If-Match`; 412 on mismatch.
	- `DELETE /documents/{id}` — delete; supports `If-Match`; 412 on mismatch.

- Vector search (pgvector)
	- `POST /documents/search/vector` — KNN within a collection. Body: `collectionId` (Guid), `embedding` (float[1536]), `limit` (default 10).
	- `POST /documents/search/vector-global` — ANN across collections with a two-step per-collection cap.
	- Indexing: HNSW indexes are created by migrations when `vector` extension is available; otherwise sequential scan is used.

ETags and conditional requests
- Lists and items return weak ETags. If the ETag you send in `If-None-Match` matches, you’ll get `304 Not Modified`.
- `PUT`/`DELETE` accept `If-Match`; if it doesn’t match the current ETag, you’ll get `412 Precondition Failed`.

Development diagnostics
- During development and E2E, the Database service adds `X-Tansu-Db` to responses to surface the normalized tenant database name (e.g., `tansu_tenant_e2e_server_ank`). This header is not intended for production.

### 13.3 CI pipeline (GitHub Actions)

- CI workflow file: `.github/workflows/e2e.yml`.
- What it does:
	- Provisions a PostgreSQL service (localhost:5432) for the Database service.
	- Builds the solution, launches services in the background, waits for the gateway to become ready, then runs the E2E test project.
	- Publishes TRX test results as an artifact.
- When it runs:
	- On pushes and pull requests targeting `master`.

### 13.4 Troubleshooting test failures

- Gateway not ready:
	- Confirm `http://localhost:8080/health/ready` (or your configured HTTPS URL) returns 200. If not, inspect gateway logs and dependent service health endpoints (see 13.1).
- Database provisioning failures:
	- Ensure PostgreSQL is reachable at `localhost:5432` and credentials match dev settings.
	- Verify the `Provisioning` options in `TansuCloud.Database` (AdminConnectionString, extensions) align with your environment.
- Certificate issues:
	- Local tests ignore TLS validation by design. For browser access, trust the dev cert or enable TLS on the gateway as described in section 5.
- Identity/token issues:
	- Check `/.well-known/openid-configuration` via gateway under `/identity` and verify `/identity/connect/token` is reachable.

## Appendix A: Docker Compose Examples

- Base compose
- Enabling TLS with volumes and env
- Overriding ports and networks

### A.1 Enable TLS on the gateway (dev or prod)

```yaml
services:
	gateway:
		image: tansucloud-gateway
		ports:
			- "80:8080"    # HTTP
			- "443:8443"   # HTTPS (container listens on 8443)
		volumes:
			- ./certs:/certs:ro
		environment:
			- Kestrel__Endpoints__Https__Url=https://0.0.0.0:8443
			- Kestrel__Endpoints__Https__Certificate__Path=/certs/gateway.pfx
			- GATEWAY_CERT_PASSWORD=${GATEWAY_CERT_PASSWORD}
		depends_on:
			identity:
				condition: service_healthy
			dashboard:
				condition: service_healthy
			db:
				condition: service_healthy
			storage:
				condition: service_healthy
```

Place your `gateway.pfx` under `./certs` and set `GATEWAY_CERT_PASSWORD` in your shell or a `.env` file.

## Appendix B: Configuration Keys

- Services:*BaseUrl
- Oidc:Issuer, Oidc:Authority (dashboard)
- OpenTelemetry:Otlp:Endpoint
- Gateway:Cors:AllowedOrigins
- Kestrel:Endpoints:Http/Https (or env: Kestrel__Endpoints__Https__Url, Kestrel__Endpoints__Https__Certificate__Path)

## Appendix C: Useful Endpoints

- / (gateway health text)
- /health/live, /health/ready (all services)
- /identity/.well-known/openid-configuration
- /dashboard (UI)

### Notes

- This guide is a living document. Fill in environment-specific details (DNS, certs, backends) as they are finalized.

## Appendix D: .env example (production-like)

Place this `.env` beside `docker-compose.yml` and adjust values to your environment.

```env
PUBLIC_BASE_URL=https://app.yourdomain.com

DASHBOARD_CLIENT_SECRET=your-strong-secret

POSTGRES_USER=postgres
POSTGRES_PASSWORD=your-db-password
PGCAT_ADMIN_USER=admin
PGCAT_ADMIN_PASSWORD=your-pgcat-password

# If enabling TLS on the gateway with a PFX mounted under ./certs
GATEWAY_CERT_PASSWORD=pfx-password
```

## Redis and Outbox (Database service)

Purpose

- The Outbox pattern ensures reliable event emission: write domain changes and an "outbox event" in the same database transaction. A background worker publishes the event to Redis later.

Local/dev Redis

- Docker Compose includes `redis:latest` with a named volume `tansu-redisdata` and default port 6379.
- The Database service depends on Redis when Outbox is enabled.

Outbox configuration (Database service)

- Outbox is disabled unless a Redis connection is provided.
- Keys (env or appsettings):
	- `Outbox:RedisConnection` (e.g., `redis:6379` in compose)
	- `Outbox:Channel` (default `tansu.outbox`)
	- `Outbox:PollSeconds` (default `2`)
	- `Outbox:BatchSize` (default `100`)
	- `Outbox:MaxAttempts` (default `8`)

Idempotency for write requests

- Clients may send an `Idempotency-Key` header on write operations (e.g., create document). The Database service records the key and will return the original outcome on safe retries.
- Use a strong, unique value per logical operation. Expire/rotate keys as needed on the client side.
 - The key is stored in `outbox_events.idempotency_key` with a partial unique index to prevent duplicates (when not null). The server may retain keys for operational analysis; clients should not reuse keys across unrelated requests.

Operations

- Health: Redis container exposes `PING` in health checks; verify container is healthy before DB starts processing Outbox.
- Observability: Outbox worker logs dispatched, retried, and dead-lettered events. Metrics are exported via OpenTelemetry when configured.
- Failure handling: After max attempts, events transition to a dead-letter state; operators should inspect and decide to replay or ignore.
 - Redis channel: events are published to the configured channel (default `tansu.outbox`) as JSON envelopes including `{ tenant, collectionId?, documentId?, op }`. Consumers should treat the payload as a contract subject to additive changes.
